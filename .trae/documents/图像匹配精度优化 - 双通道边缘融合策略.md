# 多色保留筛选器与预览功能方案

根据您的要求，我们在“多色保留”基础上增加\*\*“预览 (Preview)”\*\*功能，让操作更加安全可控。

## 1. 交互流程优化

1. **进入模式**：点击“保留色”工具按钮 (`Icons.invert_colors`)。
2. **取色阶段**：

   * **取色**：点击图片，吸取颜色加入“待保留列表”（最多5个）。

   * **UI**：显示色板列表，每个色块可删除。
3. **预览阶段 (新增)**：

   * **预览按钮**：在“确定保留”按钮旁，增加一个\*\*“预览 (Preview)”\*\*按钮（图标 `Icons.visibility`）。

   * **触发行为**：

     * 点击“预览”：进入**预览状态**。

     * **视觉效果**：图片上**不被保留**的区域变暗（覆盖半透明黑色遮罩），被保留的区域保持原样高亮。这让用户能直观看到“抠图”效果。

     * **再次点击/取消**：退出预览状态，恢复原图显示。

     * **长按图像对比**：预览按钮支持“按住预览，松开恢复”，这种交互在修图软件中很常见，非常直观。

     * **预览模式下的交互**：在预览模式下（背景变暗时），如果用户发现某个该保留的地方黑了，可以直接点击那个地方——系统自动添加该处颜色到列表并刷新预览。这将形成“所见即所得”的闭环。

   * **动态更新**：在预览状态下，如果用户调整“容差 Slider”或增删颜色，预览效果应**实时更新**（这是关键体验点）。
4. **执行阶段**：

   * 点击\*\*“确定保留 (Apply)”\*\*：实际执行像素修改，退出模式。

## 2. 方案评估与优化建议

### 为什么加预览按钮是好方案？

* **性能平衡**：实时全图渲染（Masking）比较消耗资源。如果每次点击取色都强制刷新全图预览，可能会有卡顿。通过“预览按钮”手动触发，或者在预览模式下再开启高频刷新，可以兼顾性能与体验。

* **对比确认**：用户可以反复开关预览，对比原图和处理后的效果，确保没有误删重要细节。

## 3. 开发计划

### A. 状态管理 (`ScreenCaptureTestPage`)

* 新增状态：

  * `_isKeepColorMode`: 是否在保留色模式。

  * `_keepColors`: List<Color>，已选颜色。

  * `_isPreviewingKeep`: 是否正在预览。

  * `_previewMaskImage`: ui.Image?，缓存的预览遮罩（用于优化性能）。

### B. UI 组件更新

* **工具栏**：

  * 新增“保留色”模式切换按钮。

  * 在模式激活时，显示：

    * 颜色列表 (Row of Chips/Containers)。

    * 预览按钮 (`Icons.visibility`)。

    * 确认按钮 (`Icons.check`).

* **Slider**：复用现有的容差 Slider，但在预览模式下拖动它需要触发 `_updatePreview()`。

### C. 渲染层 (`KeepColorPreviewPainter`)

* 新建 `KeepColorPreviewPainter`。

* **逻辑**：

  * 接收 `image`, `keepColors`, `tolerance`。

  * 在 `paint` 方法中，绘制半透明黑色层 (`Colors.black54`)。

  * **关键优化**：不要逐像素绘制（太慢）。

  * **高性能方案**：

    * 使用 `ShaderMask` 或 `ColorFilter`？难以实现多色距离判断。

    * **方案**：在 `ScreenCaptureTestPage` 中异步计算一个 `Uint8List` 的 Mask 图片（匹配像素=透明，不匹配=黑色）。

    * Painter 只负责把这张 Mask 图片覆盖在原图上。

### D. 算法实现

* `_generatePreviewMask()`: 遍历像素，生成 Mask 图片。

* `_performMultiColorKeep()`: 实际应用修改。

## 4. 总结

本方案将实现一个专业的\*\*“取色 -> 预览调优 -> 确认”\*\*工作流，配合实时 Mask 渲染，能极大提升复杂背景去处的成功率。
