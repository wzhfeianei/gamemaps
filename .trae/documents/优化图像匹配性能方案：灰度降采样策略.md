根据您的要求，为了达到 20ms 的极致性能，我将实施以下 **“预加载 + 零拷贝 + 金字塔匹配”** 方案：

### 核心优化策略

1.  **预加载与专用格式（Preload & Specialized Format）**：
    *   引入 `ImageTemplate` 类，将模板图片**预先解码**并加载到内存中，转换为 OpenCV 专用的 `cv.Mat` 格式。
    *   在预加载阶段就完成**灰度化**和**金字塔降采样**（生成小尺寸模板），避免在每次匹配时重复计算。

2.  **零拷贝（Zero Copy / Main Thread）**：
    *   **移除 `compute` (Isolate)**：跨 Isolate 传输图像数据存在拷贝和序列化开销（通常在 10ms+）。
    *   **主线程 FFI 调用**：直接在主线程调用 `opencv_dart` 的 C++ 接口。由于我们采用了高效的降采样算法，匹配计算本身将非常快（<5ms），不会阻塞 UI，从而实现真正的“零拷贝”调用和极低延迟。

3.  **算法升级：金字塔灰度匹配**：
    *   **解码优化**：源图像直接以 **灰度模式 (`IMREAD_GRAYSCALE`)** 解码，减少内存占用和转换开销。
    *   **分级匹配**：
        1.  **粗匹配**：使用预先生成的缩小版模板，在缩小后的源图上进行快速匹配。
        2.  **精匹配**：根据粗匹配结果，在原图的局部区域（ROI）进行一次精确匹配。

### 执行计划

1.  **重构 `ImageMatchingService`**：
    *   新增 `createTemplate` 方法：接收模板数据，预处理生成灰度图和缩略图，返回 `ImageTemplate` 对象。
    *   重构 `matchTemplate` 方法：接收 `ImageTemplate` 对象，在主线程直接执行金字塔匹配逻辑。

2.  **更新 UI 逻辑**：
    *   当用户选择右侧图片时，立即调用 `createTemplate` 进行预处理。
    *   点击“Find Match”时，直接复用已处理好的模板对象。

此方案预计将总耗时从 200ms+ 降低至 20-40ms 范围（取决于源图解码速度），满足高性能需求。