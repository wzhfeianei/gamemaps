# 图片二值化功能实现计划

## 1. 理论回答：二值化对匹配速度的影响

**结论**：
*   **计算速度**：对于 `cv.matchTemplate` 而言，图像是二值图（0/255）还是灰度图（0-255），**计算速度完全一致**。OpenCV 底层使用的是浮点数卷积或 FFT，并没有针对二值图进行特殊的位运算加速。
*   **最快方案**：二值化后的图像配合 **Direct Unmasked (无掩码全图匹配)** 或 **Pyramid Hybrid (金字塔混合)** 模式通常最快。
    *   **原因**：二值化可以将复杂的背景统一处理为纯黑（0），这样就不需要使用 Mask 来剔除背景。无 Mask 的匹配可以利用 FFT 加速，比带 Mask 的匹配快很多。

## 2. 实施计划

我将为您实现“二值化”预处理功能，以便您验证这一结论。

### 步骤 1: 扩展 `ImagePreprocessor` 类
在 `lib/services/image_preprocessor.dart` 中添加 `binarizeImage` 方法：
*   **输入**：`cv.Mat` (BGRA 或 BGR)
*   **参数**：
    *   `threshold`: 阈值（默认 127）。
    *   `inverse`: 是否反转（默认 false）。
*   **逻辑**：
    1.  转灰度。
    2.  如果存在 Alpha 通道，将 Alpha=0 的区域强制设为黑色 (0)。
    3.  应用 `cv.threshold` 进行二值化（支持 Otsu 自动阈值）。
    4.  返回二值化后的灰度图。

### 步骤 2: 更新 UI (`ScreenCaptureTestPage`)
在 `lib/components/ui/screen_capture_test_page.dart` 的工具栏中添加：
*   **二值化按钮**：点击后对右侧图片执行二值化。
*   **阈值滑块**：在弹出的对话框中调整阈值，实时预览二值化效果。

### 预期效果
您可以通过点击“二值化”按钮将图标变为黑白两色（背景为黑），然后选择 **Pyramid Hybrid** 或 **Direct Unmasked** 算法进行查找，观察是否能获得更快的速度或更稳定的识别率（尤其是在光照变化导致灰度值波动的情况下，二值化有奇效）。
