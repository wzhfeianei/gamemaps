## 问题分析
- **现象**：游戏全屏（尤其是独占全屏）时，`PrintWindow` 截图失败（黑屏或无法获取内容）。
- **原因**：
  - `PrintWindow` 依赖 `WM_PRINT` 消息或 DWM 重定向表面。独占全屏游戏直接渲染到显卡 Front Buffer，绕过 DWM，且不响应 GDI 重绘消息。
  - 虽然 `BitBlt` 对桌面 DC (`GetDC(NULL)`) 在某些“全屏优化”模式下可能有效，但 `PrintWindow` 针对特定窗口句柄几乎必定失败。

## 解决方案
鉴于引入 DXGI/WGC 需要较大的架构变动（C++/WinRT 依赖），我们采取一种**混合回退策略**来解决当前问题，这也是在不注入 DLL 的前提下 GDI 能做到的极限：

1. **检测全屏前台窗口**：
   - 在 `CaptureWindowImage` 中，检查目标窗口是否处于前台 (`GetForegroundWindow`) 且其尺寸与屏幕分辨率一致（即全屏状态）。

2. **策略降级**：
   - 如果目标是**前台全屏窗口**：放弃 `PrintWindow`，改用 `BitBlt` 截取**整个屏幕 DC** (`GetDC(NULL)`) 的对应区域。
     - 逻辑：全屏游戏此时正显示在屏幕上，直接截屏比请求窗口重绘更可靠。
   - 如果目标是**后台窗口**或**普通窗口**：保持原有的 `PrintWindow` 逻辑（支持后台/被遮挡截图）。

## 实现步骤
1. 修改 `CaptureWindowImage` 函数。
2. 增加判断：如果 `hwnd` 等于 `GetForegroundWindow()` 且窗口 Rect 等于屏幕分辨率：
   - 使用 `GetDC(NULL)` 获取屏幕 DC。
   - 使用 `BitBlt` 截取该区域。
3. 否则保留原有 `PrintWindow` 流程。

这能解决大部分“看起来是全屏”的游戏截图问题（依赖 Windows 的全屏优化）。对于强制独占且绕过 DWM 的老游戏，GDI 确实无能为力，但这是目前代码架构下的最优解。